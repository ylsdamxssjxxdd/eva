# 软件工程师工具实现与重构说明

本文面向本仓库中“软件工程师（Engineer）”相关能力的实现与重构，详细解释设计目标、模块划分、依赖发现策略、进程执行封装、跨平台差异、稳定性与安全性、以及与 UI/Prompt 的集成方式，并给出后续扩展路线图。

## 1. 设计目标
- 可靠：避免“终端能用、程序里找不到”的路径/环境不一致问题，显式工作目录与环境变量，容错并给出可诊断信息。
- 跨平台：Windows/Linux 一致的行为抽象，处理 Windows 特有的 python3 命名与 App Execution Aliases、Shell 语义差异等。
- 可观测：在 UI 中暴露环境探测结果（Python/Git/CMake 路径、版本、PATH），降低排障成本。
- 可扩展：统一的执行封装与依赖发现，便于把其它工具链迁移到同一规范（后续 doctor/venv 管理、SD/Whisper 脚本等）。
- 安全与可维护：尽量避免字符串拼接执行命令；必要时限定 PATH 影响范围；输出统一使用 UTF-8/本地编码合理转换。

## 2. 架构总览
- 核心模块
  - ProcessRunner（进程执行封装）
    - 文件：`src/utils/processrunner.h, src/utils/processrunner.cpp`
    - 作用：统一子进程启动/超时/STDOUT/STDERR 采集；平台 Shell 执行；PATH 前置注入；可定位可执行文件。
  - DependencyResolver（依赖发现）
    - 文件：`src/utils/depresolver.h, src/utils/depresolver.cpp`
    - 作用：发现并校验 Python3（优先 venv、Windows 支持 `py -3`）、发现 Git/CMake；提供简易 doctor 报告。
  - xTool.execute_command（工具“执行命令”）
    - 修改点：改用 ProcessRunner 执行，固定工作目录为 `EVA_WORK/`，标准输出/错误合并回显。
    - 文件：`src/xtool.cpp`
  - Engineer 环境检查（checkPython）
    - 修改点：改为通过 DependencyResolver 发现 Python，追加 Git/CMake 路径信息，写入工程师系统信息（用于 Prompt）。
    - 文件：`src/widget/widget_funcs.cpp`
- 关联模块
  - DeviceManager：解析后端可执行（`llama-server` 等）放置位置与“设备后端”选择，供本地推理用。
  - PathUtil：在 Windows 将路径转为 ASCII 可接受形式，避免三方工具窄字符 API 读写失败。

## 3. 依赖发现策略（DependencyResolver）
### 3.1 Python 3 发现顺序
1) 项目本地 venv（优先）：
   - Windows：`<项目>/.venv/Scripts/python.exe`、`<项目>/venv/Scripts/python.exe`
   - Linux：`<项目>/.venv/bin/python3`、`<项目>/venv/bin/python3`
2) Windows `py` 启动器：尝试 `py -3`，并通过 `sys.version_info` 校验主版本为 3。
3) PATH 中的可执行：`python3`、`python`（Windows 同时考虑 `.exe`）。

每个候选均执行一次轻量校验：`-c "import sys; print(str(sys.version_info[0])+'.'+str(sys.version_info[1]))"`，确保主版本为 3，避免误命中 Python 2 或损坏环境。

发现结果返回 ExecSpec：
- `program`：用于调用的程序名（或绝对路径）
- `extraArgs`：调用时需要预置的参数（如 Windows 的 `py -3`）
- `absolutePath`：实际解释器绝对路径（可缓存展示）
- `version`：已探测到的版本字符串

### 3.2 其它依赖
- Git/CMake：通过 `QStandardPaths::findExecutable()` 在 PATH 中解析（Windows 同时搜索 WindowsApps 别名目录）。
- 本地 llama.cpp 可执行：仍由 `DeviceManager::programPath()` 按选择的后端（cpu/cuda/vulkan/opencl）解析。

### 3.3 Doctor 报告
- 汇总 PATH、Python 发现结果（版本+路径+调用方案）、Git/CMake 是否可见。
- 用途：在 UI/设置页或工具调用返回中展示，便于用户一键复制排障信息。

## 4. 进程执行封装（ProcessRunner）
### 4.1 API
- `run(program, args, workingDir, env, timeoutMs)`：直接执行程序；显式工作目录；超时（0 表示不限）；返回 `ProcessResult{exitCode, timedOut, stdOut, stdErr}`。
- `runShellCommand(line, workingDir, env, timeoutMs)`：平台 Shell 包装执行（Windows `cmd.exe /c`，Linux `/bin/sh -lc`），用于需要管道/通配符等 Shell 特性的场景。
- `envWithPathPrepend(paths)`：构造派生环境，将给定路径前置到 PATH，避免污染系统级环境变量。
- `findExecutable(name)`：利用 Qt 的查找逻辑解析 PATH；Windows 额外检查 WindowsApps 别名目录。

### 4.2 关键约束
- 始终显式设置 `workingDir`（工程内统一使用 `<应用目录>/EVA_WORK`）。
- 输出合并与编码：
  - Windows：以本地编码（Local8Bit）读取；
  - 其它平台：UTF-8 读取；
  - UI 层统一按 UTF-8 显示（仓库约定）。
- 超时与杀进程：超时后主动 kill 并 wait，避免僵尸子进程。

## 5. 跨平台细节与常见坑
- Windows：
  - `python3` 可执行往往不存在。优先 `py -3` 或工程内 venv；若仅有 `python.exe`，需版本校验。
  - App Execution Aliases（WindowsApps）会影响 `python` 可见性，且不同会话/策略可能关闭该别名。
  - PowerShell 别名与命令名冲突（`curl`/`where` 等）——本项目执行命令默认走 `cmd.exe /c`，避免语义差异。
- Linux：
  - 非交互式进程不加载 shell profile，PATH 可能与终端不同；必要时用 `envWithPathPrepend()` 注入 `/usr/local/bin:/usr/bin:/bin`。
- 32/64 位、管理员与非管理员会话的 PATH 视图差异：尽量依赖绝对路径和本地 venv，减少不确定性。

## 6. 与 UI/Prompt 的集成
- 工程师系统信息（ENGINEER_SYSTEM_INFO）：
  - 填充项：操作系统、日期、默认 Shell、编译器信息、Python 环境（版本与解释器路径）、当前工作目录（`<应用>/EVA_WORK`）。
  - 生成逻辑：`Widget::checkPython()` 通过 DependencyResolver 发现 Python，同时附带 Git/CMake 路径；编译器信息由 `checkCompile()` 收集。
- 工具调用协议：
  - Prompt 中包含 `<tools>…</tools>` 的工具签名与 `<tool_call>…</tool_call>` 的调用返回规约。
  - LLM 一次只调用一个工具，必须等待工具返回结果后再继续下一步（避免竞态）。
- execute_command：
  - 以 `ProcessRunner::runShellCommand()` 执行，工作目录固定在 `EVA_WORK`，输出合并回显；Linux 自动补全 PATH 基础目录。

## 7. 安全与健壮性
- 参数传递优先使用“程序+参数”方式，尽量避免将未转义的用户输入直接拼到 Shell 命令中；确须使用 Shell 时，仅在执行层进行。
- 作用域化 PATH 注入：仅对子进程环境生效，不污染系统环境。
- 绝对路径优先：一旦解析到真实可执行文件路径，尽量缓存并复用。
- 日志可观测性：失败时保留退出码、是否超时、STDERR 片段；UI 层面可扩展为“Doctor”面板。

## 8. 性能与体验
- 轻量发现：Python 版本校验只执行极短命令；
- 可加缓存：`findExecutable()` 结果与 `ExecSpec` 可在进程内缓存，以减少重复查找（后续可以引入 LRU/简单静态缓存）。
- 长任务输出：现有 UI 已做流式追加；后续可为某些工具增加心跳/进度抽样。

## 9. 现状与改动清单（关键代码位置）
- 新增
  - `src/utils/processrunner.h, src/utils/processrunner.cpp`
  - `src/utils/depresolver.h, src/utils/depresolver.cpp`
- 替换/改动
  - `src/xtool.cpp`：execute_command 改为使用 ProcessRunner；保持行为一致但更稳健。
  - `src/widget/widget_funcs.cpp`：checkPython 改为使用 DependencyResolver；在工程师信息块中追加 Git/CMake 信息。
  - `cmake/Targets.cmake`：加入新源文件。

## 10. 使用与扩展示例
### 10.1 直接执行可执行文件（不经 Shell）
```cpp
QProcessEnvironment env = ProcessRunner::envWithPathPrepend({/* 如 venv 的 Scripts 目录 */});
ProcessResult r = ProcessRunner::run(exe, {"--help"}, workDir, env, 5000);
if (r.timedOut) { /* 超时处理 */ }
if (r.exitCode != 0) { /* 失败处理：r.stdErr */ }
```

### 10.2 使用平台 Shell 执行单行命令
```cpp
QProcessEnvironment env = QProcessEnvironment::systemEnvironment();
ProcessResult r = ProcessRunner::runShellCommand("git --version", workDir, env);
```

### 10.3 发现 Python 3
```cpp
ExecSpec py = DependencyResolver::discoverPython3(projectDir);
if (py.program.isEmpty()) { /* 引导安装或创建 venv */ }
QString ver = DependencyResolver::pythonVersion(py);
```

## 11. 路线图
- Doctor 面板（UI）：以只读表单/文本展示 PATH、Python/Git/CMake、后端程序路径与版本；一键复制到剪贴板。
- venv 管理：一键创建/修复 `.venv`（`python -m venv .venv`）并在子进程 PATH 前置注入；可选安装常用包。
- 全量迁移：将 Expend 模块（如模型转换脚本）执行路径改为 DependencyResolver + ProcessRunner，统一行为。
- 结果缓存：在进程内缓存 `ExecSpec` 与 `findExecutable()` 结果；为长任务增加进度心跳。

## 12. 常见问题（FAQ）
- 终端能跑、程序里报“找不到 python3”？
  - Windows 常见。请优先勾选/使用本地 venv 或安装 Python Launcher（py），程序会优先尝试 `py -3`。
- PowerShell 里 `curl` 跟 Linux 不一样？
  - 已统一改用 `cmd.exe /c` 执行命令，避免 PS 别名行为差异；必要时直接调用 `curl.exe`。
- 非交互环境 PATH 变短？
  - 子进程会显式注入基础目录；如仍缺失，可在设置中补充或启用本地 venv。

---

以上实现已在 Windows（MinGW 静态）完成编译验证。Linux 下兼容路径一致；若遇到差异，建议先通过 Doctor 信息核对 PATH 与可执行解析结果。
